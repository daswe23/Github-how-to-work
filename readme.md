## Описание некоторых функций работы с **Git**

Для начала необходимо открыть командную строку Git Bash.

Изначально пользователь находится в домашней директории C:\Users\%USERNAME%.

## Список команд для перемещения в файлообменнике.

Отобразить текущую директорию
```bash
pwd
```

Показать файлы в текущей папке. Флаг -а отобразит так же скрытые файлы, который начинаются с точки (.gitignore например)
```bash
ls -a
```

Перейти в необходимую папку (из доступных)
```bash
cd testfolder
```

По этой команде создается **папка** с указанным названием (второе слово).
```bash
mkdir testfolder
```

Создается **файл** с указанным названием.
```bash
touch readme.md
```

Отобразится содержимое файла.
```bash
cat readme.md
```


_Удаление через команды ниже приведет к полному удалению файлов без предварительного помещения в корзину_

```bash
rm readme.md
```
- удаление файла.

```bash
rmdir testfolder
```
- удаление папки.

```bash
rm -r testfolder
```
- удаление папки и все, что она содержит.

## Команды для работы непосредственно с **Git**

Для создания репозитория необходимо перейти в нужную директорию и создать папку. Далее создаем репозиторий с помощью команды:
```bash
git init
```
Создаем необходимые нам файлы (вручную или через терминал), обязательно добавляем файл README.md, чтобы следующему разработчику было понятно о чем проект, для чего и прочие нюансы.
Далее инициализируем команду, чтобы добавить все файлы репозитория в отслеживаемые:
```bash
git add --all
```
После этого можно зафиксировать изменения по файлам с помощью команды:
```bash
git commit -m "Первый коммит!"
```
Для фиксации дальнейших изменений потребуется так же сначала добавить файлы в отслеживаемые и уже после "закоммитить".

## Создание SSH-ключа для связывания репозиториев и образования безопасного канала обмена данными.

Для генерации переходим в корневую директорию (cd ~) и вызываем первую команду. Если вывалится ошибка, то вызываем вторую.

```bash
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```


```bash
$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```

Далее можно просто нажимать Enter.

После создания ключей можно проверить их наличие выводом команды 
```bash
ls -a ~/.ssh  
```
Должны отобразиться два файла с расширением .pub и без расширения. Файл с раширением является публичным ключом и для дальнейшего связывания репозитория на **Github** с локальным необходимо скопировать содержимое этого файла.

Далее содержимое этого файла нужно будет привязать в своем профиле на Github через настройки -> SSH-ключи.
Если компьютер уже связан с профилем, то повторно этого делать не нужно.

## Связка локального и удаленного репозитория.

Создайте репозиторий на Github, после чего скопируйте его SSH-ссылку. В терминале перейдите в папку проекта и введите команду:

```bash
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ_УДАЛЕННОГО_РЕПОЗИТОРИЯ%
```

Для проверки привязки можно ввести команду и получить результат:

```bash
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push) 
```

## Синхронизация удаленного и локального репозитория

Чтобы отправить изменения с локального компьютера в сеть нужно сначала создать коммит, после чего его можно будет отправить командой:

```bash
$ git push -u origin master
```

Если на **main** вылезает ошибка, попробуйте указать вместо него **master**. При дальнейших отправках изменений флаг "-u" не нужно добавлять.

## Ура, вы справились и связали все, что нужно! Поздравляю!

### Подсказка для дальнейшей работы

Посмотреть весь список коммитов:
```bash
$ git log
```
Получить весь список коммитов с сокращенным хэшем (идентификатором коммита):
```bash
$ git log --oneline
```

HEAD - это файл в репозитории, отсылающий на последний хэш (коммит). Файл лежит в папке .git.

## Статусы файлов, отображаемые по команде git status

```mermaid
flowchart TD;
  A [untracked (новый файл)] -- git add --> B{staged + tracked};
  B {staged + tracked} -- git commit --> C[tracked/comitted];
  C [tracked/comitted] -- changes --> D [modified];
  D [modified] -- git add --> B {staged + tracked};

``` 

--amend рассчитан на работу с последним коммитом (HEAD).
Дополнить коммит новыми файлами можно с помощью git commit --amend --no-edit. Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.
Изменить сообщение к коммиту позволяет команда git commit --amend -m "Обновлённое сообщение коммита".

Команда git restore --staged <file> переведёт файл из staged обратно в modified или untracked.Убрать из отслеживания
Команда git reset --hard <commit hash> «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!
Команда git restore <file> «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии. Откатить только один файл к последней версии

Команда git diff сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.
Команда git diff --staged покажет изменения в staged-файлах относительно последних закоммиченных версий.
В этом уроке вы также познакомились с командой git diff <коммит1> <коммит2>. С её помощью удобно сравнивать изменения в двух коммитах.

Если нужно, чтобы Git игнорировал какие-то файлы, стоит составить файл .gitignore.
Посмотреть, что игнорируется, можно с помощью команды git status --ignored.
Сам файл .gitignore — это обычный файл в репозитории. Его тоже стоит закоммитить.
Шаблонов много, но их легко найти в интернете вместе с примерами использования.